var treelad = {};

treelad.Class = (function() {

  function create(body) {

    function cl(cfg) {
      this.init(cfg);
    }

    for (var fcn in body) {
      cl.prototype[fcn] = body[fcn];
    }

    return cl;
  }

  function extend(target, values) {
    for (prop in values) {
      target[prop] = values[prop];
    }
    return target;
  }

  return {
    create: create,
    extend: extend
  };

})();
/**
*
*/
treelad.dom = {

};

/**
* creates an element
*/
$_element = (function() {
  function create(jsonRoot) {
    return new treelad.dom.Element(jsonRoot);
  }
  return create;
})();

/**
*
*/
treelad.dom.Element = treelad.Class.create({

    init: function(jsonRoot) {
        this.children = [];

        if (jsonRoot instanceof HTMLElement) {
            this.wrapOnly(jsonRoot);
        } else if (jsonRoot) {
            this.createRoot(jsonRoot);
        }
    },

    wrapOnly: function(jsonRoot) {
        this.domNode = jsonRoot;
        jsonRoot.wrapper = this;
    },

    createRoot: function(jsonRoot) {
        var h = this;
        this.domNode = document.createElement(jsonRoot.$_tag);
        this.domNode.wrapper = this;

        for (attr in jsonRoot) {
            if (!attr.startsWith("$_")) {
                this.domNode.setAttribute(attr.replace('_', '-'), jsonRoot[attr]);
            }
        }

        if (jsonRoot.$_append && jsonRoot.$_append.forEach) {		// JSON object collection
            jsonRoot.$_append.forEach(function(child) {
                h.createSubElement(child);
            });
        } else if (jsonRoot.$_append && jsonRoot.$_append.$_tag) {  // one JSON object
        	h.createSubElement(jsonRoot.$_append);
        } else if (jsonRoot.$_append) {
            this.domNode.innerHTML = jsonRoot.$_append;				// normal text
        }

        if (jsonRoot.$_props) {
            for (prop in jsonRoot.$_props) {
            	this.domNode[prop] = jsonRoot.$_props[prop];
            }
        }

        if (jsonRoot.$_on) {
            for (eventName in jsonRoot.$_on) {
                this.domNode.addEventListener(eventName, jsonRoot.$_on[eventName]);
            }
        }
    },

    createSubElement: function(jsonSubElement) {
        var subElement = new treelad.dom.Element(jsonSubElement);
        this.insert(subElement);
    },

    insert: function(subElement) {
        try {
        	if (subElement.dom) {
        		this.domNode.appendChild(subElement.dom());
        		this.children.push(subElement);
        	} else if ((typeof subElement) == 'string') {
        		var element = document.createTextNode(subElement);
        		this.domNode.appendChild(element);
        	} else if ((typeof subElement) == 'number') {
        		var element = document.createTextNode(subElement);
        		this.domNode.appendChild(element);
        	}
        } catch (e) {
            alert("insert: subElement=" + subElement + "\n" + e);
        }

        return subElement;
    },

    insertBefore: function(subElement, referenceElement) {
    	try {
			if (subElement.dom && referenceElement.dom) {
				this.domNode.insertBefore(subElement.dom(), referenceElement.dom());
			} else if ((typeof subElement) == 'string') {
        		var element = document.createTextNode(subElement);
        		this.domNode.insertBefore(element, referenceElement.dom());
        	} else if ((typeof subElement) == 'number') {
        		var element = document.createTextNode(subElement);
        		this.domNode.insertBefore(element, referenceElement.dom());
        	}
    	} catch (e) {
    		alert("insertBefore: subElement: " + subElement + "\n" +
    				"referenceElement: " + referenceElement + "\n" + e);
    	}
    },

    insertAfter: function(subElement, referenceElement) {
    	try {
			if (subElement.dom && referenceElement.dom) {
				referenceElement.domNode.parentNode.insertBefore(subElement.dom(), referenceElement.dom().nextSibling);
			} else if ((typeof subElement) == 'string') {
        		var element = document.createTextNode(subElement);
        		referenceElement.domNode.parentNode.insertBefore(element, referenceElement.dom().nextSibling);
        	} else if ((typeof subElement) == 'number') {
        		var element = document.createTextNode(subElement);
        		referenceElement.domNode.parentNode.insertBefore(element, referenceElement.dom().nextSibling);
        	}
    	} catch (e) {
    		alert("insertAfter: subElement: " + subElement + "\n" +
    				"referenceElement: " + referenceElement + "\n" + e);
    	}
    },

    update: function(element) {
    	var h = this;

    	(this.children || []).forEach(function(child) {
    		delete child.dom().wrapper;
    		h.dom().removeChild(child.dom());
    	});

    	if (this.children) {
    		this.children.splice(0, this.children.length);
    	}

        while (this.dom().firstChild) {
            this.dom().removeChild(this.dom().firstChild);
        }

        if (element) {
        	this.insert(element);
        }
    },

    dom: function() {
        return this.domNode;
    },

    find: function(id) {
        var result = null;
        try {
        	result = this.domNode.querySelector("#" + id);
        } catch (e) {
        	alert(e + "   " + id);
        }

        if (result !== null) {
            return result.wrapper;
        } else {
            return null;
        }
    },

    findByClass: function(className) {
        var result = null;
        try {
        	result = this.domNode.querySelector("." + className);
        } catch (e) {
        	alert(e + "   " + className);
        }

        if (result != null && result.wrapper) {
        	return result.wrapper;
        } else if (result != null && !result.wrapper) {
        	return $_element(result);
        } else {
            return null;
        }
    },

    addClassName: function(className) {
    	var classes = this.dom().className.split(" ");

    	var exists = false;
    	classes.forEach(function(_class) {
    		if (_class.trim() == className) {
    			exists = true;
    		}
    	});

    	if (false == exists) {
    		this.dom().className = this.dom().className + " " + className;
    	}
    },

    removeElement: function(subElement) {
    	try {
    		subElement.domNode.parentNode.removeChild(subElement.domNode);
    	} catch (e) {
    		alert("removeElement: subElement: " + subElement + " " + e);
    	}
    },

    removeChildren: function(subElement) {
    	try {
    		while (subElement.domNode.hasChildNodes()) {
    			subElement.domNode.removeChild(subElement.domNode.lastChild);
			}
    	} catch (e) {
    		alert("removeChildren: subElement: " + subElement + " " + e);
    	}
    },

    removeClassName: function(className) {
    	this.dom().className = this.dom().className.replace(className, "");
    },

    hasClassName: function(className) {
    	return this.dom().className.indexOf(className) > -1;
    },

    clone: function() {
    	return new treelad.dom.Element(this.domNode.cloneNode(true));
    },

    setStyle: function(style) {
    	var s = null;
    	for (s in style) {
    		this.dom().style[s] = style[s];
    	}
    }
});
/**
 *
 */
$_upgradeElement = (function() {

    function materialize(root) {
        componentHandler.upgradeElement(root.dom());
        (root.children || []).forEach(function(node) {
            $_upgradeElement(node);
        });
    }

    return materialize;
})();

treelad.utils = {

}

treelad.utils.ScriptImporter = treelad.Class.create({

  init: function(cfg) {
    this.xhttp = new XMLHttpRequest()
  },

  js: function(path) {
    var t = this;
    if (!t.openConnection(path)) {
      return;
    }

    if (t.xhttp.readyState == 4 && (t.xhttp.status == 200 || t.xhttp.status == 0)) {
      try {
        window.eval.call(window, t.xhttp.responseText);
      } catch (e) {
        alert(""+ e + "\nError importing script " + path);
      }
    }
  },

  css: function(path) {
    var t = this;
    if (!t.openConnection(path)) {
      return;
    }

    if (t.xhttp.readyState == 4 && (t.xhttp.status == 200 || t.xhttp.status == 0)) {
      try {
        var css = $_element({
          $_tag: "link",
          rel: "stylesheet",
          href: path
        });
        document.getElementsByTagName("head")[0].appendChild(css.dom());
      } catch (e) {
        alert(""+ e + "\nError importing css " + path);
      }
    }
  },

  openConnection: function(path) {
    var t = this;
    try {
      t.xhttp.open("GET", path, false);
      t.xhttp.send(null);
      return true;
    } catch(e) {
      alert(e + "\nError importing script: " + path);
      return false;
    }
  }

});

var IMPORTER = new treelad.utils.ScriptImporter({

});

function importScript(path) {
  IMPORTER.js(path);
};

function importCss(path) {
  IMPORTER.css(path);
};
